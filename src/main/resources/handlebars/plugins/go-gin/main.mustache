package main
/**
 * TokitaDevEngine version {{generatorVersion}}
 * Generated by engine {{generatorClass}}
 * Generated on {{generateDate}}
 * Developed by sulaimanfahmi@gmail.com
 */
import(
    "{{basePackage}}/src/controllers"
    "{{basePackage}}/src/configurations"
    "{{basePackage}}/src/middleware"
    "github.com/gin-gonic/gin"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    "context"
)


func main() {
    log.Printf("starting apps on port %s",configurations.GetConfig().ServerPort)
    //set database connection
    configurations.SetDatabaseConnection()
    defer configurations.GetDatabaseConnection().DB().Close()
    configurations.SetRedisConnection()
    engine := gin.Default()
    engine.Use(middleware.CorsHandler(engine))
    //health check
    engine.GET("/api/health", func(c *gin.Context) {
        return
    })
    controllers.GetRouters(engine)
    srv := &http.Server{
    Addr:    "0.0.0.0:" + configurations.GetConfig().ServerPort,
    Handler: engine,
    //WriteTimeout: time.Second * 15,
    //ReadTimeout:  time.Second * 15,
    //IdleTimeout:  time.Second * 60,
    }
    go func() {
    // service connections
    if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        log.Fatalf("listen: %s\n", err)
    }
    }()

    quit := make(chan os.Signal, 1)
    // kill (no param) default send syscanll.SIGTERM
    // kill -2 is syscall.SIGINT
    // kill -9 is syscall. SIGKILL but can"t be catch, so don't need add it
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    log.Println("Shutdown Server ...")

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server Shutdown: ", err)
    }
    log.Println("Server exiting")


}

